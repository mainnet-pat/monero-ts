"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _assert = _interopRequireDefault(require("assert"));
var _GenUtils = _interopRequireDefault(require("./GenUtils"));
var _MoneroError = _interopRequireDefault(require("./MoneroError"));
var _ThreadPool = _interopRequireDefault(require("./ThreadPool"));
var _path = _interopRequireDefault(require("path"));

/**
 * Collection of helper utilities for the library.
 */
class LibraryUtils {

  // static variables
  static LOG_LEVEL = 0;





  static MUTEX = new _ThreadPool.default(1);

  static WORKER_DIST_PATH_DEFAULT = _GenUtils.default.isBrowser() ? "/monero_web_worker.js" : function () {

    // get worker path in dist (assumes library is running from src or dist)
    let curPath = _path.default.normalize(__dirname);
    const targetPath = _path.default.join('monero-ts', 'dist');
    if (!curPath.includes(targetPath)) curPath = _path.default.join(curPath, "../../../../dist/src/main/js/common");
    return LibraryUtils.prefixWindowsPath(_path.default.join(curPath, "./MoneroWebWorker.js"));
  }();
  static WORKER_DIST_PATH = LibraryUtils.WORKER_DIST_PATH_DEFAULT;

  /**
   * Log a message.
   *
   * @param {number} level - log level of the message
   * @param {string} msg - message to log
   */
  static log(level, msg) {
    (0, _assert.default)(level === parseInt(level, 10) && level >= 0, "Log level must be an integer >= 0");
    if (LibraryUtils.LOG_LEVEL >= level) console.log(msg);
  }

  /**
   * Set the library's log level with 0 being least verbose.
   *
   * @param {number} level - the library's log level
   */
  static async setLogLevel(level) {
    (0, _assert.default)(level === parseInt(level, 10) && level >= 0, "Log level must be an integer >= 0");
    LibraryUtils.LOG_LEVEL = level;
    if (LibraryUtils.WASM_MODULE) LibraryUtils.WASM_MODULE.set_log_level(level);
    if (LibraryUtils.WORKER) await LibraryUtils.invokeWorker(undefined, "setLogLevel", [level]);
  }

  /**
   * Get the library's log level.
   *
   * @return {number} the library's log level
   */
  static getLogLevel() {
    return LibraryUtils.LOG_LEVEL;
  }

  /**
   * Get the total memory used by WebAssembly.
   * 
   * @return {Promise<number>} the total memory used by WebAssembly
   */
  static async getWasmMemoryUsed() {
    let total = 0;
    if (LibraryUtils.WORKER) total += await LibraryUtils.invokeWorker(undefined, "getWasmMemoryUsed", []);
    if (LibraryUtils.getWasmModule() && LibraryUtils.getWasmModule().HEAP8) total += LibraryUtils.getWasmModule().HEAP8.length;
    return total;
  }

  /**
   * Get the WebAssembly module in the current context (nodejs, browser main thread or worker).
   */
  static getWasmModule() {
    return LibraryUtils.WASM_MODULE;
  }

  /**
   * Load the WebAssembly keys module with caching.
   */
  static async loadKeysModule() {

    // use cache if suitable, full module supersedes keys module because it is superset
    if (LibraryUtils.WASM_MODULE) return LibraryUtils.WASM_MODULE;

    // load module
    let module = await require("../../../../dist/monero_wallet_keys")();
    LibraryUtils.WASM_MODULE = module;
    delete LibraryUtils.WASM_MODULE.then;
    LibraryUtils.initWasmModule(LibraryUtils.WASM_MODULE);
    return module;
  }

  /**
   * Load the WebAssembly full module with caching.
   * 
   * The full module is a superset of the keys module and overrides it.
   * 
   * TODO: this is separate static function from loadKeysModule() because webpack cannot bundle worker using runtime param for conditional import
   */
  static async loadFullModule() {

    // use cache if suitable, full module supersedes keys module because it is superset
    if (LibraryUtils.WASM_MODULE && LibraryUtils.FULL_LOADED) return LibraryUtils.WASM_MODULE;

    // load module
    let module = await require("../../../../dist/monero_wallet_full")();
    LibraryUtils.WASM_MODULE = module;
    delete LibraryUtils.WASM_MODULE.then;
    LibraryUtils.FULL_LOADED = true;
    LibraryUtils.initWasmModule(LibraryUtils.WASM_MODULE);
    return module;
  }

  /**
   * Register a function by id which informs if unauthorized requests (e.g.
   * self-signed certificates) should be rejected.
   * 
   * @param {string} fnId - unique identifier for the function
   * @param {function} fn - function to inform if unauthorized requests should be rejected
   */
  static setRejectUnauthorizedFn(fnId, fn) {
    if (!LibraryUtils.REJECT_UNAUTHORIZED_FNS) LibraryUtils.REJECT_UNAUTHORIZED_FNS = [];
    if (fn === undefined) delete LibraryUtils.REJECT_UNAUTHORIZED_FNS[fnId];else
    LibraryUtils.REJECT_UNAUTHORIZED_FNS[fnId] = fn;
  }

  /**
   * Indicate if unauthorized requests should be rejected.
   * 
   * @param {string} fnId - uniquely identifies the function
   */
  static isRejectUnauthorized(fnId) {
    if (!LibraryUtils.REJECT_UNAUTHORIZED_FNS[fnId]) throw new Error("No function registered with id " + fnId + " to inform if unauthorized reqs should be rejected");
    return LibraryUtils.REJECT_UNAUTHORIZED_FNS[fnId]();
  }

  /**
   * Set the path to load the worker. Defaults to "/monero_web_worker.js" in the browser
   * and "./MoneroWebWorker.js" in node.
   * 
   * @param {string} workerDistPath - path to load the worker
   */
  static setWorkerDistPath(workerDistPath) {
    let path = LibraryUtils.prefixWindowsPath(workerDistPath ? workerDistPath : LibraryUtils.WORKER_DIST_PATH_DEFAULT);
    if (path !== LibraryUtils.WORKER_DIST_PATH) delete LibraryUtils.WORKER;
    LibraryUtils.WORKER_DIST_PATH = path;
  }

  /**
   * Get a singleton instance of a worker to share.
   * 
   * @return {Worker} a worker to share among wallet instances
   */
  static async getWorker() {

    // one time initialization
    if (!LibraryUtils.WORKER) {
      if (_GenUtils.default.isBrowser()) {
        LibraryUtils.WORKER = new Worker(LibraryUtils.WORKER_DIST_PATH);
      } else {
        const Worker = require("web-worker"); // import web worker if nodejs
        LibraryUtils.WORKER = new Worker(LibraryUtils.WORKER_DIST_PATH);
      }
      LibraryUtils.WORKER_OBJECTS = {}; // store per object running in the worker

      // receive worker errors
      LibraryUtils.WORKER.onerror = function (err) {
        console.error("Error posting message to Monero web worker; is it built and copied to the app's build directory (e.g. in the root)?");
        console.log(err);
      };

      // receive worker messages
      LibraryUtils.WORKER.onmessage = function (e) {

        // lookup object id, callback function, and this arg
        let thisArg = undefined;
        let callbackFn = LibraryUtils.WORKER_OBJECTS[e.data[0]].callbacks[e.data[1]]; // look up by object id then by function name
        if (callbackFn === undefined) throw new Error("No worker callback function defined for key '" + e.data[1] + "'");
        if (callbackFn instanceof Array) {// this arg may be stored with callback function
          thisArg = callbackFn[1];
          callbackFn = callbackFn[0];
        }

        // invoke callback function with this arg and arguments
        callbackFn.apply(thisArg, e.data.slice(2));
      };
    }
    return LibraryUtils.WORKER;
  }

  static addWorkerCallback(objectId, callbackId, callbackArgs) {
    LibraryUtils.WORKER_OBJECTS[objectId].callbacks[callbackId] = callbackArgs;
  }

  static removeWorkerCallback(objectId, callbackId) {
    delete LibraryUtils.WORKER_OBJECTS[objectId].callbacks[callbackId];
  }

  static removeWorkerObject(objectId) {
    delete LibraryUtils.WORKER_OBJECTS[objectId];
  }

  /**
   * Terminate monero-ts's singleton worker.
   */
  static async terminateWorker() {
    if (LibraryUtils.WORKER) {
      LibraryUtils.WORKER.terminate();
      delete LibraryUtils.WORKER;
      LibraryUtils.WORKER = undefined;
    }
  }

  /**
   * Invoke a worker function and get the result with error handling.
   * 
   * @param {string} objectId identifies the worker object to invoke (default random id)
   * @param {string} fnName is the name of the function to invoke
   * @param {any[]} [args] are function arguments to invoke with
   * @return {any} resolves with response payload from the worker or an error
   */
  static async invokeWorker(objectId, fnName, args) {
    (0, _assert.default)(fnName.length >= 2);
    let worker = await LibraryUtils.getWorker();
    let randomObject = objectId === undefined;
    if (randomObject) objectId = _GenUtils.default.getUUID();
    if (!LibraryUtils.WORKER_OBJECTS[objectId]) LibraryUtils.WORKER_OBJECTS[objectId] = { callbacks: {} };
    let callbackId = _GenUtils.default.getUUID();
    try {
      return await new Promise((resolve, reject) => {
        LibraryUtils.WORKER_OBJECTS[objectId].callbacks[callbackId] = (resp) => {// TODO: this defines function once per callback
          delete LibraryUtils.WORKER_OBJECTS[objectId].callbacks[callbackId];
          if (randomObject) delete LibraryUtils.WORKER_OBJECTS[objectId];
          resp ? resp.error ? reject(new Error(JSON.stringify(resp.error))) : resolve(resp.result) : resolve(undefined);
        };
        worker.postMessage([objectId, fnName, callbackId].concat(args === undefined ? [] : _GenUtils.default.listify(args)));
      });
    } catch (e) {
      throw LibraryUtils.deserializeError(JSON.parse(e.message));
    }
  }

  static serializeError(err) {
    const serializedErr = { name: err.name, message: err.message, stack: err.stack };
    if (err instanceof _MoneroError.default) serializedErr.type = "MoneroError";
    return serializedErr;
  }

  static deserializeError(serializedErr) {
    const err = serializedErr.type === "MoneroError" ? new _MoneroError.default(serializedErr.message) : new Error(serializedErr.message);
    err.name = serializedErr.name;
    err.stack = err.stack + "\nWorker error: " + serializedErr.stack;
    return err;
  }

  // ------------------------------ PRIVATE HELPERS ---------------------------

  static initWasmModule(wasmModule) {
    wasmModule.taskQueue = new _ThreadPool.default(1);
    wasmModule.queueTask = async function (asyncFn) {return wasmModule.taskQueue.submit(asyncFn);};
  }

  static prefixWindowsPath(path) {
    if (/^[A-Z]:/.test(path) && path.indexOf("file://") == -1) path = "file://" + path; // prepend e.g. C: paths with file://
    return path;
  }

  static async queueTask(asyncFn) {
    return LibraryUtils.MUTEX.submit(asyncFn);
  }
}exports.default = LibraryUtils;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfYXNzZXJ0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfR2VuVXRpbHMiLCJfTW9uZXJvRXJyb3IiLCJfVGhyZWFkUG9vbCIsIl9wYXRoIiwiTGlicmFyeVV0aWxzIiwiTE9HX0xFVkVMIiwiTVVURVgiLCJUaHJlYWRQb29sIiwiV09SS0VSX0RJU1RfUEFUSF9ERUZBVUxUIiwiR2VuVXRpbHMiLCJpc0Jyb3dzZXIiLCJjdXJQYXRoIiwicGF0aCIsIm5vcm1hbGl6ZSIsIl9fZGlybmFtZSIsInRhcmdldFBhdGgiLCJqb2luIiwiaW5jbHVkZXMiLCJwcmVmaXhXaW5kb3dzUGF0aCIsIldPUktFUl9ESVNUX1BBVEgiLCJsb2ciLCJsZXZlbCIsIm1zZyIsImFzc2VydCIsInBhcnNlSW50IiwiY29uc29sZSIsInNldExvZ0xldmVsIiwiV0FTTV9NT0RVTEUiLCJzZXRfbG9nX2xldmVsIiwiV09SS0VSIiwiaW52b2tlV29ya2VyIiwidW5kZWZpbmVkIiwiZ2V0TG9nTGV2ZWwiLCJnZXRXYXNtTWVtb3J5VXNlZCIsInRvdGFsIiwiZ2V0V2FzbU1vZHVsZSIsIkhFQVA4IiwibGVuZ3RoIiwibG9hZEtleXNNb2R1bGUiLCJtb2R1bGUiLCJ0aGVuIiwiaW5pdFdhc21Nb2R1bGUiLCJsb2FkRnVsbE1vZHVsZSIsIkZVTExfTE9BREVEIiwic2V0UmVqZWN0VW5hdXRob3JpemVkRm4iLCJmbklkIiwiZm4iLCJSRUpFQ1RfVU5BVVRIT1JJWkVEX0ZOUyIsImlzUmVqZWN0VW5hdXRob3JpemVkIiwiRXJyb3IiLCJzZXRXb3JrZXJEaXN0UGF0aCIsIndvcmtlckRpc3RQYXRoIiwiZ2V0V29ya2VyIiwiV29ya2VyIiwiV09SS0VSX09CSkVDVFMiLCJvbmVycm9yIiwiZXJyIiwiZXJyb3IiLCJvbm1lc3NhZ2UiLCJlIiwidGhpc0FyZyIsImNhbGxiYWNrRm4iLCJkYXRhIiwiY2FsbGJhY2tzIiwiQXJyYXkiLCJhcHBseSIsInNsaWNlIiwiYWRkV29ya2VyQ2FsbGJhY2siLCJvYmplY3RJZCIsImNhbGxiYWNrSWQiLCJjYWxsYmFja0FyZ3MiLCJyZW1vdmVXb3JrZXJDYWxsYmFjayIsInJlbW92ZVdvcmtlck9iamVjdCIsInRlcm1pbmF0ZVdvcmtlciIsInRlcm1pbmF0ZSIsImZuTmFtZSIsImFyZ3MiLCJ3b3JrZXIiLCJyYW5kb21PYmplY3QiLCJnZXRVVUlEIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZXNwIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3VsdCIsInBvc3RNZXNzYWdlIiwiY29uY2F0IiwibGlzdGlmeSIsImRlc2VyaWFsaXplRXJyb3IiLCJwYXJzZSIsIm1lc3NhZ2UiLCJzZXJpYWxpemVFcnJvciIsInNlcmlhbGl6ZWRFcnIiLCJuYW1lIiwic3RhY2siLCJNb25lcm9FcnJvciIsInR5cGUiLCJ3YXNtTW9kdWxlIiwidGFza1F1ZXVlIiwicXVldWVUYXNrIiwiYXN5bmNGbiIsInN1Ym1pdCIsInRlc3QiLCJpbmRleE9mIiwiZXhwb3J0cyIsImRlZmF1bHQiXSwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbWFpbi90cy9jb21tb24vTGlicmFyeVV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xuaW1wb3J0IEdlblV0aWxzIGZyb20gXCIuL0dlblV0aWxzXCI7XG5pbXBvcnQgTW9uZXJvRXJyb3IgZnJvbSBcIi4vTW9uZXJvRXJyb3JcIjtcbmltcG9ydCBUaHJlYWRQb29sIGZyb20gXCIuL1RocmVhZFBvb2xcIjtcbmltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCI7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBoZWxwZXIgdXRpbGl0aWVzIGZvciB0aGUgbGlicmFyeS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlicmFyeVV0aWxzIHtcblxuICAvLyBzdGF0aWMgdmFyaWFibGVzXG4gIHN0YXRpYyBMT0dfTEVWRUwgPSAwO1xuICBzdGF0aWMgV0FTTV9NT0RVTEU6IGFueTtcbiAgc3RhdGljIFdPUktFUjogYW55O1xuICBzdGF0aWMgV09SS0VSX09CSkVDVFM6IGFueTtcbiAgc3RhdGljIEZVTExfTE9BREVEOiBhbnk7XG4gIHN0YXRpYyBSRUpFQ1RfVU5BVVRIT1JJWkVEX0ZOUzogYW55O1xuICBzdGF0aWMgcmVhZG9ubHkgTVVURVggPSBuZXcgVGhyZWFkUG9vbCgxKTtcblxuICBzdGF0aWMgV09SS0VSX0RJU1RfUEFUSF9ERUZBVUxUID0gR2VuVXRpbHMuaXNCcm93c2VyKCkgPyBcIi9tb25lcm9fd2ViX3dvcmtlci5qc1wiIDogZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBnZXQgd29ya2VyIHBhdGggaW4gZGlzdCAoYXNzdW1lcyBsaWJyYXJ5IGlzIHJ1bm5pbmcgZnJvbSBzcmMgb3IgZGlzdClcbiAgICBsZXQgY3VyUGF0aCA9IHBhdGgubm9ybWFsaXplKF9fZGlybmFtZSk7XG4gICAgY29uc3QgdGFyZ2V0UGF0aCA9IHBhdGguam9pbignbW9uZXJvLXRzJywgJ2Rpc3QnKTtcbiAgICBpZiAoIWN1clBhdGguaW5jbHVkZXModGFyZ2V0UGF0aCkpIGN1clBhdGggPSBwYXRoLmpvaW4oY3VyUGF0aCwgXCIuLi8uLi8uLi8uLi9kaXN0L3NyYy9tYWluL2pzL2NvbW1vblwiKTtcbiAgICByZXR1cm4gTGlicmFyeVV0aWxzLnByZWZpeFdpbmRvd3NQYXRoKHBhdGguam9pbihjdXJQYXRoLCBcIi4vTW9uZXJvV2ViV29ya2VyLmpzXCIpKTtcbiAgfSgpO1xuICBzdGF0aWMgV09SS0VSX0RJU1RfUEFUSCA9IExpYnJhcnlVdGlscy5XT1JLRVJfRElTVF9QQVRIX0RFRkFVTFQ7XG4gIFxuICAvKipcbiAgICogTG9nIGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsIC0gbG9nIGxldmVsIG9mIHRoZSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2cgLSBtZXNzYWdlIHRvIGxvZ1xuICAgKi9cbiAgc3RhdGljIGxvZyhsZXZlbCwgbXNnKSB7XG4gICAgYXNzZXJ0KGxldmVsID09PSBwYXJzZUludChsZXZlbCwgMTApICYmIGxldmVsID49IDAsIFwiTG9nIGxldmVsIG11c3QgYmUgYW4gaW50ZWdlciA+PSAwXCIpO1xuICAgIGlmIChMaWJyYXJ5VXRpbHMuTE9HX0xFVkVMID49IGxldmVsKSBjb25zb2xlLmxvZyhtc2cpO1xuICB9XG4gIFxuICAvKipcbiAgICogU2V0IHRoZSBsaWJyYXJ5J3MgbG9nIGxldmVsIHdpdGggMCBiZWluZyBsZWFzdCB2ZXJib3NlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgLSB0aGUgbGlicmFyeSdzIGxvZyBsZXZlbFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHNldExvZ0xldmVsKGxldmVsKSB7XG4gICAgYXNzZXJ0KGxldmVsID09PSBwYXJzZUludChsZXZlbCwgMTApICYmIGxldmVsID49IDAsIFwiTG9nIGxldmVsIG11c3QgYmUgYW4gaW50ZWdlciA+PSAwXCIpO1xuICAgIExpYnJhcnlVdGlscy5MT0dfTEVWRUwgPSBsZXZlbDtcbiAgICBpZiAoTGlicmFyeVV0aWxzLldBU01fTU9EVUxFKSBMaWJyYXJ5VXRpbHMuV0FTTV9NT0RVTEUuc2V0X2xvZ19sZXZlbChsZXZlbCk7XG4gICAgaWYgKExpYnJhcnlVdGlscy5XT1JLRVIpIGF3YWl0IExpYnJhcnlVdGlscy5pbnZva2VXb3JrZXIodW5kZWZpbmVkLCBcInNldExvZ0xldmVsXCIsIFtsZXZlbF0pO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IHRoZSBsaWJyYXJ5J3MgbG9nIGxldmVsLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBsaWJyYXJ5J3MgbG9nIGxldmVsXG4gICAqL1xuICBzdGF0aWMgZ2V0TG9nTGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTGlicmFyeVV0aWxzLkxPR19MRVZFTDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgdG90YWwgbWVtb3J5IHVzZWQgYnkgV2ViQXNzZW1ibHkuXG4gICAqIFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPG51bWJlcj59IHRoZSB0b3RhbCBtZW1vcnkgdXNlZCBieSBXZWJBc3NlbWJseVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGdldFdhc21NZW1vcnlVc2VkKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBpZiAoTGlicmFyeVV0aWxzLldPUktFUikgdG90YWwgKz0gYXdhaXQgTGlicmFyeVV0aWxzLmludm9rZVdvcmtlcih1bmRlZmluZWQsIFwiZ2V0V2FzbU1lbW9yeVVzZWRcIiwgW10pIGFzIG51bWJlcjtcbiAgICBpZiAoTGlicmFyeVV0aWxzLmdldFdhc21Nb2R1bGUoKSAmJiBMaWJyYXJ5VXRpbHMuZ2V0V2FzbU1vZHVsZSgpLkhFQVA4KSB0b3RhbCArPSBMaWJyYXJ5VXRpbHMuZ2V0V2FzbU1vZHVsZSgpLkhFQVA4Lmxlbmd0aDtcbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0IChub2RlanMsIGJyb3dzZXIgbWFpbiB0aHJlYWQgb3Igd29ya2VyKS5cbiAgICovXG4gIHN0YXRpYyBnZXRXYXNtTW9kdWxlKCkge1xuICAgIHJldHVybiBMaWJyYXJ5VXRpbHMuV0FTTV9NT0RVTEU7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBXZWJBc3NlbWJseSBrZXlzIG1vZHVsZSB3aXRoIGNhY2hpbmcuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgbG9hZEtleXNNb2R1bGUoKSB7XG4gICAgXG4gICAgLy8gdXNlIGNhY2hlIGlmIHN1aXRhYmxlLCBmdWxsIG1vZHVsZSBzdXBlcnNlZGVzIGtleXMgbW9kdWxlIGJlY2F1c2UgaXQgaXMgc3VwZXJzZXRcbiAgICBpZiAoTGlicmFyeVV0aWxzLldBU01fTU9EVUxFKSByZXR1cm4gTGlicmFyeVV0aWxzLldBU01fTU9EVUxFO1xuICAgIFxuICAgIC8vIGxvYWQgbW9kdWxlXG4gICAgbGV0IG1vZHVsZSA9IGF3YWl0IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9kaXN0L21vbmVyb193YWxsZXRfa2V5c1wiKSgpO1xuICAgIExpYnJhcnlVdGlscy5XQVNNX01PRFVMRSA9IG1vZHVsZVxuICAgIGRlbGV0ZSBMaWJyYXJ5VXRpbHMuV0FTTV9NT0RVTEUudGhlbjtcbiAgICBMaWJyYXJ5VXRpbHMuaW5pdFdhc21Nb2R1bGUoTGlicmFyeVV0aWxzLldBU01fTU9EVUxFKTtcbiAgICByZXR1cm4gbW9kdWxlO1xuICB9XG4gIFxuICAvKipcbiAgICogTG9hZCB0aGUgV2ViQXNzZW1ibHkgZnVsbCBtb2R1bGUgd2l0aCBjYWNoaW5nLlxuICAgKiBcbiAgICogVGhlIGZ1bGwgbW9kdWxlIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGtleXMgbW9kdWxlIGFuZCBvdmVycmlkZXMgaXQuXG4gICAqIFxuICAgKiBUT0RPOiB0aGlzIGlzIHNlcGFyYXRlIHN0YXRpYyBmdW5jdGlvbiBmcm9tIGxvYWRLZXlzTW9kdWxlKCkgYmVjYXVzZSB3ZWJwYWNrIGNhbm5vdCBidW5kbGUgd29ya2VyIHVzaW5nIHJ1bnRpbWUgcGFyYW0gZm9yIGNvbmRpdGlvbmFsIGltcG9ydFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGxvYWRGdWxsTW9kdWxlKCkge1xuICAgIFxuICAgIC8vIHVzZSBjYWNoZSBpZiBzdWl0YWJsZSwgZnVsbCBtb2R1bGUgc3VwZXJzZWRlcyBrZXlzIG1vZHVsZSBiZWNhdXNlIGl0IGlzIHN1cGVyc2V0XG4gICAgaWYgKExpYnJhcnlVdGlscy5XQVNNX01PRFVMRSAmJiBMaWJyYXJ5VXRpbHMuRlVMTF9MT0FERUQpIHJldHVybiBMaWJyYXJ5VXRpbHMuV0FTTV9NT0RVTEU7XG4gICAgXG4gICAgLy8gbG9hZCBtb2R1bGVcbiAgICBsZXQgbW9kdWxlID0gYXdhaXQgcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Rpc3QvbW9uZXJvX3dhbGxldF9mdWxsXCIpKCk7XG4gICAgTGlicmFyeVV0aWxzLldBU01fTU9EVUxFID0gbW9kdWxlXG4gICAgZGVsZXRlIExpYnJhcnlVdGlscy5XQVNNX01PRFVMRS50aGVuO1xuICAgIExpYnJhcnlVdGlscy5GVUxMX0xPQURFRCA9IHRydWU7XG4gICAgTGlicmFyeVV0aWxzLmluaXRXYXNtTW9kdWxlKExpYnJhcnlVdGlscy5XQVNNX01PRFVMRSk7XG4gICAgcmV0dXJuIG1vZHVsZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgZnVuY3Rpb24gYnkgaWQgd2hpY2ggaW5mb3JtcyBpZiB1bmF1dGhvcml6ZWQgcmVxdWVzdHMgKGUuZy5cbiAgICogc2VsZi1zaWduZWQgY2VydGlmaWNhdGVzKSBzaG91bGQgYmUgcmVqZWN0ZWQuXG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm5JZCAtIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBmdW5jdGlvbiB0byBpbmZvcm0gaWYgdW5hdXRob3JpemVkIHJlcXVlc3RzIHNob3VsZCBiZSByZWplY3RlZFxuICAgKi9cbiAgc3RhdGljIHNldFJlamVjdFVuYXV0aG9yaXplZEZuKGZuSWQsIGZuKSB7XG4gICAgaWYgKCFMaWJyYXJ5VXRpbHMuUkVKRUNUX1VOQVVUSE9SSVpFRF9GTlMpIExpYnJhcnlVdGlscy5SRUpFQ1RfVU5BVVRIT1JJWkVEX0ZOUyA9IFtdO1xuICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKSBkZWxldGUgTGlicmFyeVV0aWxzLlJFSkVDVF9VTkFVVEhPUklaRURfRk5TW2ZuSWRdO1xuICAgIGVsc2UgTGlicmFyeVV0aWxzLlJFSkVDVF9VTkFVVEhPUklaRURfRk5TW2ZuSWRdID0gZm47XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSBpZiB1bmF1dGhvcml6ZWQgcmVxdWVzdHMgc2hvdWxkIGJlIHJlamVjdGVkLlxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZuSWQgLSB1bmlxdWVseSBpZGVudGlmaWVzIHRoZSBmdW5jdGlvblxuICAgKi9cbiAgc3RhdGljIGlzUmVqZWN0VW5hdXRob3JpemVkKGZuSWQpIHtcbiAgICBpZiAoIUxpYnJhcnlVdGlscy5SRUpFQ1RfVU5BVVRIT1JJWkVEX0ZOU1tmbklkXSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZnVuY3Rpb24gcmVnaXN0ZXJlZCB3aXRoIGlkIFwiICsgZm5JZCArIFwiIHRvIGluZm9ybSBpZiB1bmF1dGhvcml6ZWQgcmVxcyBzaG91bGQgYmUgcmVqZWN0ZWRcIik7XG4gICAgcmV0dXJuIExpYnJhcnlVdGlscy5SRUpFQ1RfVU5BVVRIT1JJWkVEX0ZOU1tmbklkXSgpO1xuICB9XG4gIFxuICAvKipcbiAgICogU2V0IHRoZSBwYXRoIHRvIGxvYWQgdGhlIHdvcmtlci4gRGVmYXVsdHMgdG8gXCIvbW9uZXJvX3dlYl93b3JrZXIuanNcIiBpbiB0aGUgYnJvd3NlclxuICAgKiBhbmQgXCIuL01vbmVyb1dlYldvcmtlci5qc1wiIGluIG5vZGUuXG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gd29ya2VyRGlzdFBhdGggLSBwYXRoIHRvIGxvYWQgdGhlIHdvcmtlclxuICAgKi9cbiAgc3RhdGljIHNldFdvcmtlckRpc3RQYXRoKHdvcmtlckRpc3RQYXRoKSB7XG4gICAgbGV0IHBhdGggPSBMaWJyYXJ5VXRpbHMucHJlZml4V2luZG93c1BhdGgod29ya2VyRGlzdFBhdGggPyB3b3JrZXJEaXN0UGF0aCA6IExpYnJhcnlVdGlscy5XT1JLRVJfRElTVF9QQVRIX0RFRkFVTFQpO1xuICAgIGlmIChwYXRoICE9PSBMaWJyYXJ5VXRpbHMuV09SS0VSX0RJU1RfUEFUSCkgZGVsZXRlIExpYnJhcnlVdGlscy5XT1JLRVI7XG4gICAgTGlicmFyeVV0aWxzLldPUktFUl9ESVNUX1BBVEggPSBwYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIHdvcmtlciB0byBzaGFyZS5cbiAgICogXG4gICAqIEByZXR1cm4ge1dvcmtlcn0gYSB3b3JrZXIgdG8gc2hhcmUgYW1vbmcgd2FsbGV0IGluc3RhbmNlc1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGdldFdvcmtlcigpIHtcbiAgICBcbiAgICAvLyBvbmUgdGltZSBpbml0aWFsaXphdGlvblxuICAgIGlmICghTGlicmFyeVV0aWxzLldPUktFUikge1xuICAgICAgaWYgKEdlblV0aWxzLmlzQnJvd3NlcigpKSB7XG4gICAgICAgIExpYnJhcnlVdGlscy5XT1JLRVIgPSBuZXcgV29ya2VyKExpYnJhcnlVdGlscy5XT1JLRVJfRElTVF9QQVRIKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IFdvcmtlciA9IHJlcXVpcmUoXCJ3ZWItd29ya2VyXCIpOyAvLyBpbXBvcnQgd2ViIHdvcmtlciBpZiBub2RlanNcbiAgICAgICAgTGlicmFyeVV0aWxzLldPUktFUiA9IG5ldyBXb3JrZXIoTGlicmFyeVV0aWxzLldPUktFUl9ESVNUX1BBVEgpO1xuICAgICAgfVxuICAgICAgTGlicmFyeVV0aWxzLldPUktFUl9PQkpFQ1RTID0ge307ICAvLyBzdG9yZSBwZXIgb2JqZWN0IHJ1bm5pbmcgaW4gdGhlIHdvcmtlclxuICAgICAgXG4gICAgICAvLyByZWNlaXZlIHdvcmtlciBlcnJvcnNcbiAgICAgIExpYnJhcnlVdGlscy5XT1JLRVIub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcG9zdGluZyBtZXNzYWdlIHRvIE1vbmVybyB3ZWIgd29ya2VyOyBpcyBpdCBidWlsdCBhbmQgY29waWVkIHRvIHRoZSBhcHAncyBidWlsZCBkaXJlY3RvcnkgKGUuZy4gaW4gdGhlIHJvb3QpP1wiKTtcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIHJlY2VpdmUgd29ya2VyIG1lc3NhZ2VzXG4gICAgICBMaWJyYXJ5VXRpbHMuV09SS0VSLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgXG4gICAgICAgIC8vIGxvb2t1cCBvYmplY3QgaWQsIGNhbGxiYWNrIGZ1bmN0aW9uLCBhbmQgdGhpcyBhcmdcbiAgICAgICAgbGV0IHRoaXNBcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjYWxsYmFja0ZuID0gTGlicmFyeVV0aWxzLldPUktFUl9PQkpFQ1RTW2UuZGF0YVswXV0uY2FsbGJhY2tzW2UuZGF0YVsxXV07IC8vIGxvb2sgdXAgYnkgb2JqZWN0IGlkIHRoZW4gYnkgZnVuY3Rpb24gbmFtZVxuICAgICAgICBpZiAoY2FsbGJhY2tGbiA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB3b3JrZXIgY2FsbGJhY2sgZnVuY3Rpb24gZGVmaW5lZCBmb3Iga2V5ICdcIiArIGUuZGF0YVsxXSArIFwiJ1wiKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrRm4gaW5zdGFuY2VvZiBBcnJheSkgeyAgLy8gdGhpcyBhcmcgbWF5IGJlIHN0b3JlZCB3aXRoIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrRm5bMV07XG4gICAgICAgICAgY2FsbGJhY2tGbiA9IGNhbGxiYWNrRm5bMF07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGludm9rZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIHRoaXMgYXJnIGFuZCBhcmd1bWVudHNcbiAgICAgICAgY2FsbGJhY2tGbi5hcHBseSh0aGlzQXJnLCBlLmRhdGEuc2xpY2UoMikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTGlicmFyeVV0aWxzLldPUktFUjtcbiAgfVxuXG4gIHN0YXRpYyBhZGRXb3JrZXJDYWxsYmFjayhvYmplY3RJZCwgY2FsbGJhY2tJZCwgY2FsbGJhY2tBcmdzKSB7XG4gICAgTGlicmFyeVV0aWxzLldPUktFUl9PQkpFQ1RTW29iamVjdElkXS5jYWxsYmFja3NbY2FsbGJhY2tJZF0gPSBjYWxsYmFja0FyZ3M7XG4gIH1cblxuICBzdGF0aWMgcmVtb3ZlV29ya2VyQ2FsbGJhY2sob2JqZWN0SWQsIGNhbGxiYWNrSWQpIHtcbiAgICBkZWxldGUgTGlicmFyeVV0aWxzLldPUktFUl9PQkpFQ1RTW29iamVjdElkXS5jYWxsYmFja3NbY2FsbGJhY2tJZF07XG4gIH1cblxuICBzdGF0aWMgcmVtb3ZlV29ya2VyT2JqZWN0KG9iamVjdElkKSB7XG4gICAgZGVsZXRlIExpYnJhcnlVdGlscy5XT1JLRVJfT0JKRUNUU1tvYmplY3RJZF07XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBUZXJtaW5hdGUgbW9uZXJvLXRzJ3Mgc2luZ2xldG9uIHdvcmtlci5cbiAgICovXG4gIHN0YXRpYyBhc3luYyB0ZXJtaW5hdGVXb3JrZXIoKSB7XG4gICAgaWYgKExpYnJhcnlVdGlscy5XT1JLRVIpIHtcbiAgICAgIExpYnJhcnlVdGlscy5XT1JLRVIudGVybWluYXRlKCk7XG4gICAgICBkZWxldGUgTGlicmFyeVV0aWxzLldPUktFUjtcbiAgICAgIExpYnJhcnlVdGlscy5XT1JLRVIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZSBhIHdvcmtlciBmdW5jdGlvbiBhbmQgZ2V0IHRoZSByZXN1bHQgd2l0aCBlcnJvciBoYW5kbGluZy5cbiAgICogXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvYmplY3RJZCBpZGVudGlmaWVzIHRoZSB3b3JrZXIgb2JqZWN0IHRvIGludm9rZSAoZGVmYXVsdCByYW5kb20gaWQpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWUgaXMgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICAgKiBAcGFyYW0ge2FueVtdfSBbYXJnc10gYXJlIGZ1bmN0aW9uIGFyZ3VtZW50cyB0byBpbnZva2Ugd2l0aFxuICAgKiBAcmV0dXJuIHthbnl9IHJlc29sdmVzIHdpdGggcmVzcG9uc2UgcGF5bG9hZCBmcm9tIHRoZSB3b3JrZXIgb3IgYW4gZXJyb3JcbiAgICovXG4gIHN0YXRpYyBhc3luYyBpbnZva2VXb3JrZXIob2JqZWN0SWQsIGZuTmFtZSwgYXJncykge1xuICAgIGFzc2VydChmbk5hbWUubGVuZ3RoID49IDIpO1xuICAgIGxldCB3b3JrZXIgPSBhd2FpdCBMaWJyYXJ5VXRpbHMuZ2V0V29ya2VyKCk7XG4gICAgbGV0IHJhbmRvbU9iamVjdCA9IG9iamVjdElkID09PSB1bmRlZmluZWQ7XG4gICAgaWYgKHJhbmRvbU9iamVjdCkgb2JqZWN0SWQgPSBHZW5VdGlscy5nZXRVVUlEKCk7XG4gICAgaWYgKCFMaWJyYXJ5VXRpbHMuV09SS0VSX09CSkVDVFNbb2JqZWN0SWRdKSBMaWJyYXJ5VXRpbHMuV09SS0VSX09CSkVDVFNbb2JqZWN0SWRdID0ge2NhbGxiYWNrczoge319O1xuICAgIGxldCBjYWxsYmFja0lkID0gR2VuVXRpbHMuZ2V0VVVJRCgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBMaWJyYXJ5VXRpbHMuV09SS0VSX09CSkVDVFNbb2JqZWN0SWRdLmNhbGxiYWNrc1tjYWxsYmFja0lkXSA9IChyZXNwKSA9PiB7ICAvLyBUT0RPOiB0aGlzIGRlZmluZXMgZnVuY3Rpb24gb25jZSBwZXIgY2FsbGJhY2tcbiAgICAgICAgICBkZWxldGUgTGlicmFyeVV0aWxzLldPUktFUl9PQkpFQ1RTW29iamVjdElkXS5jYWxsYmFja3NbY2FsbGJhY2tJZF07XG4gICAgICAgICAgaWYgKHJhbmRvbU9iamVjdCkgZGVsZXRlIExpYnJhcnlVdGlscy5XT1JLRVJfT0JKRUNUU1tvYmplY3RJZF07XG4gICAgICAgICAgcmVzcCA/IChyZXNwLmVycm9yID8gcmVqZWN0KG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShyZXNwLmVycm9yKSkpIDogcmVzb2x2ZShyZXNwLnJlc3VsdCkpIDogcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICB9O1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoW29iamVjdElkLCBmbk5hbWUsIGNhbGxiYWNrSWRdLmNvbmNhdChhcmdzID09PSB1bmRlZmluZWQgPyBbXSA6IEdlblV0aWxzLmxpc3RpZnkoYXJncykpKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgdGhyb3cgTGlicmFyeVV0aWxzLmRlc2VyaWFsaXplRXJyb3IoSlNPTi5wYXJzZShlLm1lc3NhZ2UpKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgc2VyaWFsaXplRXJyb3IoZXJyKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZEVycjogYW55ID0geyBuYW1lOiBlcnIubmFtZSwgbWVzc2FnZTogZXJyLm1lc3NhZ2UsIHN0YWNrOiBlcnIuc3RhY2sgfTtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgTW9uZXJvRXJyb3IpIHNlcmlhbGl6ZWRFcnIudHlwZSA9IFwiTW9uZXJvRXJyb3JcIjtcbiAgICByZXR1cm4gc2VyaWFsaXplZEVycjtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdGF0aWMgZGVzZXJpYWxpemVFcnJvcihzZXJpYWxpemVkRXJyKSB7XG4gICAgY29uc3QgZXJyID0gc2VyaWFsaXplZEVyci50eXBlID09PSBcIk1vbmVyb0Vycm9yXCIgPyBuZXcgTW9uZXJvRXJyb3Ioc2VyaWFsaXplZEVyci5tZXNzYWdlKSA6IG5ldyBFcnJvcihzZXJpYWxpemVkRXJyLm1lc3NhZ2UpO1xuICAgIGVyci5uYW1lID0gc2VyaWFsaXplZEVyci5uYW1lO1xuICAgIGVyci5zdGFjayA9IGVyci5zdGFjayArIFwiXFxuV29ya2VyIGVycm9yOiBcIiArIHNlcmlhbGl6ZWRFcnIuc3RhY2s7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFBSSVZBVEUgSEVMUEVSUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gIHByb3RlY3RlZCBzdGF0aWMgaW5pdFdhc21Nb2R1bGUod2FzbU1vZHVsZSkge1xuICAgIHdhc21Nb2R1bGUudGFza1F1ZXVlID0gbmV3IFRocmVhZFBvb2woMSk7XG4gICAgd2FzbU1vZHVsZS5xdWV1ZVRhc2sgPSBhc3luYyBmdW5jdGlvbihhc3luY0ZuKSB7IHJldHVybiB3YXNtTW9kdWxlLnRhc2tRdWV1ZS5zdWJtaXQoYXN5bmNGbik7IH1cbiAgfVxuICBcbiAgcHJvdGVjdGVkIHN0YXRpYyBwcmVmaXhXaW5kb3dzUGF0aChwYXRoKSB7XG4gICAgaWYgKC9eW0EtWl06Ly50ZXN0KHBhdGgpICYmIHBhdGguaW5kZXhPZihcImZpbGU6Ly9cIikgPT0gLTEpIHBhdGggPSBcImZpbGU6Ly9cIiArIHBhdGg7IC8vIHByZXBlbmQgZS5nLiBDOiBwYXRocyB3aXRoIGZpbGU6Ly9cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBxdWV1ZVRhc2s8VD4oYXN5bmNGbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiBMaWJyYXJ5VXRpbHMuTVVURVguc3VibWl0KGFzeW5jRm4pO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJ5TEFBQSxJQUFBQSxPQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBQyxTQUFBLEdBQUFGLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRSxZQUFBLEdBQUFILHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRyxXQUFBLEdBQUFKLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBSSxLQUFBLEdBQUFMLHNCQUFBLENBQUFDLE9BQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ2UsTUFBTUssWUFBWSxDQUFDOztFQUVoQztFQUNBLE9BQU9DLFNBQVMsR0FBRyxDQUFDOzs7Ozs7RUFNcEIsT0FBZ0JDLEtBQUssR0FBRyxJQUFJQyxtQkFBVSxDQUFDLENBQUMsQ0FBQzs7RUFFekMsT0FBT0Msd0JBQXdCLEdBQUdDLGlCQUFRLENBQUNDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsdUJBQXVCLEdBQUcsWUFBVzs7SUFFNUY7SUFDQSxJQUFJQyxPQUFPLEdBQUdDLGFBQUksQ0FBQ0MsU0FBUyxDQUFDQyxTQUFTLENBQUM7SUFDdkMsTUFBTUMsVUFBVSxHQUFHSCxhQUFJLENBQUNJLElBQUksQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDO0lBQ2pELElBQUksQ0FBQ0wsT0FBTyxDQUFDTSxRQUFRLENBQUNGLFVBQVUsQ0FBQyxFQUFFSixPQUFPLEdBQUdDLGFBQUksQ0FBQ0ksSUFBSSxDQUFDTCxPQUFPLEVBQUUscUNBQXFDLENBQUM7SUFDdEcsT0FBT1AsWUFBWSxDQUFDYyxpQkFBaUIsQ0FBQ04sYUFBSSxDQUFDSSxJQUFJLENBQUNMLE9BQU8sRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO0VBQ25GLENBQUMsQ0FBQyxDQUFDO0VBQ0gsT0FBT1EsZ0JBQWdCLEdBQUdmLFlBQVksQ0FBQ0ksd0JBQXdCOztFQUUvRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxPQUFPWSxHQUFHQSxDQUFDQyxLQUFLLEVBQUVDLEdBQUcsRUFBRTtJQUNyQixJQUFBQyxlQUFNLEVBQUNGLEtBQUssS0FBS0csUUFBUSxDQUFDSCxLQUFLLEVBQUUsRUFBRSxDQUFDLElBQUlBLEtBQUssSUFBSSxDQUFDLEVBQUUsbUNBQW1DLENBQUM7SUFDeEYsSUFBSWpCLFlBQVksQ0FBQ0MsU0FBUyxJQUFJZ0IsS0FBSyxFQUFFSSxPQUFPLENBQUNMLEdBQUcsQ0FBQ0UsR0FBRyxDQUFDO0VBQ3ZEOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDRSxhQUFhSSxXQUFXQSxDQUFDTCxLQUFLLEVBQUU7SUFDOUIsSUFBQUUsZUFBTSxFQUFDRixLQUFLLEtBQUtHLFFBQVEsQ0FBQ0gsS0FBSyxFQUFFLEVBQUUsQ0FBQyxJQUFJQSxLQUFLLElBQUksQ0FBQyxFQUFFLG1DQUFtQyxDQUFDO0lBQ3hGakIsWUFBWSxDQUFDQyxTQUFTLEdBQUdnQixLQUFLO0lBQzlCLElBQUlqQixZQUFZLENBQUN1QixXQUFXLEVBQUV2QixZQUFZLENBQUN1QixXQUFXLENBQUNDLGFBQWEsQ0FBQ1AsS0FBSyxDQUFDO0lBQzNFLElBQUlqQixZQUFZLENBQUN5QixNQUFNLEVBQUUsTUFBTXpCLFlBQVksQ0FBQzBCLFlBQVksQ0FBQ0MsU0FBUyxFQUFFLGFBQWEsRUFBRSxDQUFDVixLQUFLLENBQUMsQ0FBQztFQUM3Rjs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBT1csV0FBV0EsQ0FBQSxFQUFXO0lBQzNCLE9BQU81QixZQUFZLENBQUNDLFNBQVM7RUFDL0I7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtFQUNFLGFBQWE0QixpQkFBaUJBLENBQUEsRUFBb0I7SUFDaEQsSUFBSUMsS0FBSyxHQUFHLENBQUM7SUFDYixJQUFJOUIsWUFBWSxDQUFDeUIsTUFBTSxFQUFFSyxLQUFLLElBQUksTUFBTTlCLFlBQVksQ0FBQzBCLFlBQVksQ0FBQ0MsU0FBUyxFQUFFLG1CQUFtQixFQUFFLEVBQUUsQ0FBVztJQUMvRyxJQUFJM0IsWUFBWSxDQUFDK0IsYUFBYSxDQUFDLENBQUMsSUFBSS9CLFlBQVksQ0FBQytCLGFBQWEsQ0FBQyxDQUFDLENBQUNDLEtBQUssRUFBRUYsS0FBSyxJQUFJOUIsWUFBWSxDQUFDK0IsYUFBYSxDQUFDLENBQUMsQ0FBQ0MsS0FBSyxDQUFDQyxNQUFNO0lBQzFILE9BQU9ILEtBQUs7RUFDZDs7RUFFQTtBQUNGO0FBQ0E7RUFDRSxPQUFPQyxhQUFhQSxDQUFBLEVBQUc7SUFDckIsT0FBTy9CLFlBQVksQ0FBQ3VCLFdBQVc7RUFDakM7O0VBRUE7QUFDRjtBQUNBO0VBQ0UsYUFBYVcsY0FBY0EsQ0FBQSxFQUFHOztJQUU1QjtJQUNBLElBQUlsQyxZQUFZLENBQUN1QixXQUFXLEVBQUUsT0FBT3ZCLFlBQVksQ0FBQ3VCLFdBQVc7O0lBRTdEO0lBQ0EsSUFBSVksTUFBTSxHQUFHLE1BQU14QyxPQUFPLENBQUMscUNBQXFDLENBQUMsQ0FBQyxDQUFDO0lBQ25FSyxZQUFZLENBQUN1QixXQUFXLEdBQUdZLE1BQU07SUFDakMsT0FBT25DLFlBQVksQ0FBQ3VCLFdBQVcsQ0FBQ2EsSUFBSTtJQUNwQ3BDLFlBQVksQ0FBQ3FDLGNBQWMsQ0FBQ3JDLFlBQVksQ0FBQ3VCLFdBQVcsQ0FBQztJQUNyRCxPQUFPWSxNQUFNO0VBQ2Y7O0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxhQUFhRyxjQUFjQSxDQUFBLEVBQUc7O0lBRTVCO0lBQ0EsSUFBSXRDLFlBQVksQ0FBQ3VCLFdBQVcsSUFBSXZCLFlBQVksQ0FBQ3VDLFdBQVcsRUFBRSxPQUFPdkMsWUFBWSxDQUFDdUIsV0FBVzs7SUFFekY7SUFDQSxJQUFJWSxNQUFNLEdBQUcsTUFBTXhDLE9BQU8sQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDLENBQUM7SUFDbkVLLFlBQVksQ0FBQ3VCLFdBQVcsR0FBR1ksTUFBTTtJQUNqQyxPQUFPbkMsWUFBWSxDQUFDdUIsV0FBVyxDQUFDYSxJQUFJO0lBQ3BDcEMsWUFBWSxDQUFDdUMsV0FBVyxHQUFHLElBQUk7SUFDL0J2QyxZQUFZLENBQUNxQyxjQUFjLENBQUNyQyxZQUFZLENBQUN1QixXQUFXLENBQUM7SUFDckQsT0FBT1ksTUFBTTtFQUNmOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBT0ssdUJBQXVCQSxDQUFDQyxJQUFJLEVBQUVDLEVBQUUsRUFBRTtJQUN2QyxJQUFJLENBQUMxQyxZQUFZLENBQUMyQyx1QkFBdUIsRUFBRTNDLFlBQVksQ0FBQzJDLHVCQUF1QixHQUFHLEVBQUU7SUFDcEYsSUFBSUQsRUFBRSxLQUFLZixTQUFTLEVBQUUsT0FBTzNCLFlBQVksQ0FBQzJDLHVCQUF1QixDQUFDRixJQUFJLENBQUMsQ0FBQztJQUNuRXpDLFlBQVksQ0FBQzJDLHVCQUF1QixDQUFDRixJQUFJLENBQUMsR0FBR0MsRUFBRTtFQUN0RDs7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBT0Usb0JBQW9CQSxDQUFDSCxJQUFJLEVBQUU7SUFDaEMsSUFBSSxDQUFDekMsWUFBWSxDQUFDMkMsdUJBQXVCLENBQUNGLElBQUksQ0FBQyxFQUFFLE1BQU0sSUFBSUksS0FBSyxDQUFDLGlDQUFpQyxHQUFHSixJQUFJLEdBQUcsb0RBQW9ELENBQUM7SUFDakssT0FBT3pDLFlBQVksQ0FBQzJDLHVCQUF1QixDQUFDRixJQUFJLENBQUMsQ0FBQyxDQUFDO0VBQ3JEOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFLE9BQU9LLGlCQUFpQkEsQ0FBQ0MsY0FBYyxFQUFFO0lBQ3ZDLElBQUl2QyxJQUFJLEdBQUdSLFlBQVksQ0FBQ2MsaUJBQWlCLENBQUNpQyxjQUFjLEdBQUdBLGNBQWMsR0FBRy9DLFlBQVksQ0FBQ0ksd0JBQXdCLENBQUM7SUFDbEgsSUFBSUksSUFBSSxLQUFLUixZQUFZLENBQUNlLGdCQUFnQixFQUFFLE9BQU9mLFlBQVksQ0FBQ3lCLE1BQU07SUFDdEV6QixZQUFZLENBQUNlLGdCQUFnQixHQUFHUCxJQUFJO0VBQ3RDOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7RUFDRSxhQUFhd0MsU0FBU0EsQ0FBQSxFQUFHOztJQUV2QjtJQUNBLElBQUksQ0FBQ2hELFlBQVksQ0FBQ3lCLE1BQU0sRUFBRTtNQUN4QixJQUFJcEIsaUJBQVEsQ0FBQ0MsU0FBUyxDQUFDLENBQUMsRUFBRTtRQUN4Qk4sWUFBWSxDQUFDeUIsTUFBTSxHQUFHLElBQUl3QixNQUFNLENBQUNqRCxZQUFZLENBQUNlLGdCQUFnQixDQUFDO01BQ2pFLENBQUMsTUFBTTtRQUNMLE1BQU1rQyxNQUFNLEdBQUd0RCxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztRQUN0Q0ssWUFBWSxDQUFDeUIsTUFBTSxHQUFHLElBQUl3QixNQUFNLENBQUNqRCxZQUFZLENBQUNlLGdCQUFnQixDQUFDO01BQ2pFO01BQ0FmLFlBQVksQ0FBQ2tELGNBQWMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFFOztNQUVuQztNQUNBbEQsWUFBWSxDQUFDeUIsTUFBTSxDQUFDMEIsT0FBTyxHQUFHLFVBQVNDLEdBQUcsRUFBRTtRQUMxQy9CLE9BQU8sQ0FBQ2dDLEtBQUssQ0FBQyxxSEFBcUgsQ0FBQztRQUNwSWhDLE9BQU8sQ0FBQ0wsR0FBRyxDQUFDb0MsR0FBRyxDQUFDO01BQ2xCLENBQUM7O01BRUQ7TUFDQXBELFlBQVksQ0FBQ3lCLE1BQU0sQ0FBQzZCLFNBQVMsR0FBRyxVQUFTQyxDQUFDLEVBQUU7O1FBRTFDO1FBQ0EsSUFBSUMsT0FBTyxHQUFHN0IsU0FBUztRQUN2QixJQUFJOEIsVUFBVSxHQUFHekQsWUFBWSxDQUFDa0QsY0FBYyxDQUFDSyxDQUFDLENBQUNHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDQyxTQUFTLENBQUNKLENBQUMsQ0FBQ0csSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5RSxJQUFJRCxVQUFVLEtBQUs5QixTQUFTLEVBQUUsTUFBTSxJQUFJa0IsS0FBSyxDQUFDLCtDQUErQyxHQUFHVSxDQUFDLENBQUNHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7UUFDaEgsSUFBSUQsVUFBVSxZQUFZRyxLQUFLLEVBQUUsQ0FBRztVQUNsQ0osT0FBTyxHQUFHQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1VBQ3ZCQSxVQUFVLEdBQUdBLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDNUI7O1FBRUE7UUFDQUEsVUFBVSxDQUFDSSxLQUFLLENBQUNMLE9BQU8sRUFBRUQsQ0FBQyxDQUFDRyxJQUFJLENBQUNJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztNQUM1QyxDQUFDO0lBQ0g7SUFDQSxPQUFPOUQsWUFBWSxDQUFDeUIsTUFBTTtFQUM1Qjs7RUFFQSxPQUFPc0MsaUJBQWlCQSxDQUFDQyxRQUFRLEVBQUVDLFVBQVUsRUFBRUMsWUFBWSxFQUFFO0lBQzNEbEUsWUFBWSxDQUFDa0QsY0FBYyxDQUFDYyxRQUFRLENBQUMsQ0FBQ0wsU0FBUyxDQUFDTSxVQUFVLENBQUMsR0FBR0MsWUFBWTtFQUM1RTs7RUFFQSxPQUFPQyxvQkFBb0JBLENBQUNILFFBQVEsRUFBRUMsVUFBVSxFQUFFO0lBQ2hELE9BQU9qRSxZQUFZLENBQUNrRCxjQUFjLENBQUNjLFFBQVEsQ0FBQyxDQUFDTCxTQUFTLENBQUNNLFVBQVUsQ0FBQztFQUNwRTs7RUFFQSxPQUFPRyxrQkFBa0JBLENBQUNKLFFBQVEsRUFBRTtJQUNsQyxPQUFPaEUsWUFBWSxDQUFDa0QsY0FBYyxDQUFDYyxRQUFRLENBQUM7RUFDOUM7O0VBRUE7QUFDRjtBQUNBO0VBQ0UsYUFBYUssZUFBZUEsQ0FBQSxFQUFHO0lBQzdCLElBQUlyRSxZQUFZLENBQUN5QixNQUFNLEVBQUU7TUFDdkJ6QixZQUFZLENBQUN5QixNQUFNLENBQUM2QyxTQUFTLENBQUMsQ0FBQztNQUMvQixPQUFPdEUsWUFBWSxDQUFDeUIsTUFBTTtNQUMxQnpCLFlBQVksQ0FBQ3lCLE1BQU0sR0FBR0UsU0FBUztJQUNqQztFQUNGOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxhQUFhRCxZQUFZQSxDQUFDc0MsUUFBUSxFQUFFTyxNQUFNLEVBQUVDLElBQUksRUFBRTtJQUNoRCxJQUFBckQsZUFBTSxFQUFDb0QsTUFBTSxDQUFDdEMsTUFBTSxJQUFJLENBQUMsQ0FBQztJQUMxQixJQUFJd0MsTUFBTSxHQUFHLE1BQU16RSxZQUFZLENBQUNnRCxTQUFTLENBQUMsQ0FBQztJQUMzQyxJQUFJMEIsWUFBWSxHQUFHVixRQUFRLEtBQUtyQyxTQUFTO0lBQ3pDLElBQUkrQyxZQUFZLEVBQUVWLFFBQVEsR0FBRzNELGlCQUFRLENBQUNzRSxPQUFPLENBQUMsQ0FBQztJQUMvQyxJQUFJLENBQUMzRSxZQUFZLENBQUNrRCxjQUFjLENBQUNjLFFBQVEsQ0FBQyxFQUFFaEUsWUFBWSxDQUFDa0QsY0FBYyxDQUFDYyxRQUFRLENBQUMsR0FBRyxFQUFDTCxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUM7SUFDbkcsSUFBSU0sVUFBVSxHQUFHNUQsaUJBQVEsQ0FBQ3NFLE9BQU8sQ0FBQyxDQUFDO0lBQ25DLElBQUk7TUFDRixPQUFPLE1BQU0sSUFBSUMsT0FBTyxDQUFDLENBQUNDLE9BQU8sRUFBRUMsTUFBTSxLQUFLO1FBQzVDOUUsWUFBWSxDQUFDa0QsY0FBYyxDQUFDYyxRQUFRLENBQUMsQ0FBQ0wsU0FBUyxDQUFDTSxVQUFVLENBQUMsR0FBRyxDQUFDYyxJQUFJLEtBQUssQ0FBRztVQUN6RSxPQUFPL0UsWUFBWSxDQUFDa0QsY0FBYyxDQUFDYyxRQUFRLENBQUMsQ0FBQ0wsU0FBUyxDQUFDTSxVQUFVLENBQUM7VUFDbEUsSUFBSVMsWUFBWSxFQUFFLE9BQU8xRSxZQUFZLENBQUNrRCxjQUFjLENBQUNjLFFBQVEsQ0FBQztVQUM5RGUsSUFBSSxHQUFJQSxJQUFJLENBQUMxQixLQUFLLEdBQUd5QixNQUFNLENBQUMsSUFBSWpDLEtBQUssQ0FBQ21DLElBQUksQ0FBQ0MsU0FBUyxDQUFDRixJQUFJLENBQUMxQixLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUd3QixPQUFPLENBQUNFLElBQUksQ0FBQ0csTUFBTSxDQUFDLEdBQUlMLE9BQU8sQ0FBQ2xELFNBQVMsQ0FBQztRQUNqSCxDQUFDO1FBQ0Q4QyxNQUFNLENBQUNVLFdBQVcsQ0FBQyxDQUFDbkIsUUFBUSxFQUFFTyxNQUFNLEVBQUVOLFVBQVUsQ0FBQyxDQUFDbUIsTUFBTSxDQUFDWixJQUFJLEtBQUs3QyxTQUFTLEdBQUcsRUFBRSxHQUFHdEIsaUJBQVEsQ0FBQ2dGLE9BQU8sQ0FBQ2IsSUFBSSxDQUFDLENBQUMsQ0FBQztNQUM3RyxDQUFDLENBQUM7SUFDSixDQUFDLENBQUMsT0FBT2pCLENBQU0sRUFBRTtNQUNmLE1BQU12RCxZQUFZLENBQUNzRixnQkFBZ0IsQ0FBQ04sSUFBSSxDQUFDTyxLQUFLLENBQUNoQyxDQUFDLENBQUNpQyxPQUFPLENBQUMsQ0FBQztJQUM1RDtFQUNGOztFQUVBLE9BQU9DLGNBQWNBLENBQUNyQyxHQUFHLEVBQUU7SUFDekIsTUFBTXNDLGFBQWtCLEdBQUcsRUFBRUMsSUFBSSxFQUFFdkMsR0FBRyxDQUFDdUMsSUFBSSxFQUFFSCxPQUFPLEVBQUVwQyxHQUFHLENBQUNvQyxPQUFPLEVBQUVJLEtBQUssRUFBRXhDLEdBQUcsQ0FBQ3dDLEtBQUssQ0FBQyxDQUFDO0lBQ3JGLElBQUl4QyxHQUFHLFlBQVl5QyxvQkFBVyxFQUFFSCxhQUFhLENBQUNJLElBQUksR0FBRyxhQUFhO0lBQ2xFLE9BQU9KLGFBQWE7RUFDdEI7O0VBRUEsT0FBaUJKLGdCQUFnQkEsQ0FBQ0ksYUFBYSxFQUFFO0lBQy9DLE1BQU10QyxHQUFHLEdBQUdzQyxhQUFhLENBQUNJLElBQUksS0FBSyxhQUFhLEdBQUcsSUFBSUQsb0JBQVcsQ0FBQ0gsYUFBYSxDQUFDRixPQUFPLENBQUMsR0FBRyxJQUFJM0MsS0FBSyxDQUFDNkMsYUFBYSxDQUFDRixPQUFPLENBQUM7SUFDNUhwQyxHQUFHLENBQUN1QyxJQUFJLEdBQUdELGFBQWEsQ0FBQ0MsSUFBSTtJQUM3QnZDLEdBQUcsQ0FBQ3dDLEtBQUssR0FBR3hDLEdBQUcsQ0FBQ3dDLEtBQUssR0FBRyxrQkFBa0IsR0FBR0YsYUFBYSxDQUFDRSxLQUFLO0lBQ2hFLE9BQU94QyxHQUFHO0VBQ1o7O0VBRUE7O0VBRUEsT0FBaUJmLGNBQWNBLENBQUMwRCxVQUFVLEVBQUU7SUFDMUNBLFVBQVUsQ0FBQ0MsU0FBUyxHQUFHLElBQUk3RixtQkFBVSxDQUFDLENBQUMsQ0FBQztJQUN4QzRGLFVBQVUsQ0FBQ0UsU0FBUyxHQUFHLGdCQUFlQyxPQUFPLEVBQUUsQ0FBRSxPQUFPSCxVQUFVLENBQUNDLFNBQVMsQ0FBQ0csTUFBTSxDQUFDRCxPQUFPLENBQUMsQ0FBRSxDQUFDO0VBQ2pHOztFQUVBLE9BQWlCcEYsaUJBQWlCQSxDQUFDTixJQUFJLEVBQUU7SUFDdkMsSUFBSSxTQUFTLENBQUM0RixJQUFJLENBQUM1RixJQUFJLENBQUMsSUFBSUEsSUFBSSxDQUFDNkYsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFN0YsSUFBSSxHQUFHLFNBQVMsR0FBR0EsSUFBSSxDQUFDLENBQUM7SUFDcEYsT0FBT0EsSUFBSTtFQUNiOztFQUVBLGFBQWF5RixTQUFTQSxDQUFJQyxPQUF5QixFQUFjO0lBQy9ELE9BQU9sRyxZQUFZLENBQUNFLEtBQUssQ0FBQ2lHLE1BQU0sQ0FBQ0QsT0FBTyxDQUFDO0VBQzNDO0FBQ0YsQ0FBQ0ksT0FBQSxDQUFBQyxPQUFBLEdBQUF2RyxZQUFBIn0=